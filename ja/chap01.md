<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[['\$','\$'],['\\(','\\)']],processEscapes:true},CommonHTML: {matchFontHeight:false}});</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

# 第1章 評価履歴

## 準備
次のコードを書きなさい。

```python
import numpy as np
```

## 評価履歴
次の行列$$D_{u}$$はユーザ$$u$$の評価履歴である。

$$
D_{u} = \left[
 \begin{array}{rrr}
  5 & 3 & +1 \\
  6 & 2 & +1 \\
  4 & 1 & +1 \\
  8 & 5 & -1 \\
  2 & 4 & -1 \\
  3 & 6 & -1 \\
  7 & 6 & -1 \\
  4 & 2 &  ? \\
  5 & 1 &  ? \\
  8 & 6 &  ? \\
  3 & 4 &  ? \\
  4 & 7 &  ? \\
  4 & 4 &  ? \\
 \end{array}
\right]
$$

このとき、次の問いに答えなさい。

### 01 評価履歴の生成
$$D_{u}$$を`ndarray`として生成するコードを書きなさい。得られた`ndarray`を`Du`とすること。

★
1. `numpy.nan`を使う。
2. `numpy.array()`を使う。

### 02 評価履歴の表示
`Du`の内容を表示するコードを書きなさい。

結果
```bash
Du = 
[[ 5.  3.  1.]
 [ 6.  2.  1.]
 [ 4.  1.  1.]
 [ 8.  5. -1.]
 [ 2.  4. -1.]
 [ 3.  6. -1.]
 [ 7.  6. -1.]
 [ 4.  2. nan]
 [ 5.  1. nan]
 [ 8.  6. nan]
 [ 3.  4. nan]
 [ 4.  7. nan]
 [ 4.  4. nan]]
 ```

★
1. `print()`を使う。

★★
1. `print()`を使う。
2. `str.format()`を使う。

### 03 評価履歴の形状
`Du`の形状を取得し、表示するコードを書きなさい。

結果
```bash
Duの形状 = (13, 3)
```

★
1. `ndarray.shape`を使う。
2. `print()`を使う。

### 04 評価履歴の行数
`Du`の行数を取得し、表示するコードを書きなさい。

結果
```bash
Duの行数 = 13
```

★
1. `ndarray.shape`を使う。
2. `print()`を使う。

### 05 評価履歴の列数
`Du`の列数を取得し、表示するコードを書きなさい。

結果
```bash
Duの列数 = 3
```

★
1. `ndarray.shape`を使う。
2. `print()`を使う。

### 06 評価履歴の全要素数
`Du`の全要素数を取得し、表示するコードを書きなさい。ただし、欠損値も含む。

結果
```bash
Duの全要素数 = 39
```

★
1. `ndarray.size`を使う。
2. `print()`を使う。

## アイテム
評価履歴$$D_{u}$$の$$i$$行目はアイテム$$i \in I$$に関するデータを表す。ここで、評価履歴$$D_{u}$$に含まれるアイテム集合は$$I = \{0, 1, \ldots, 12\}$$となる。$$D_{u}$$の$$i$$行目の1列目と2列目はアイテム$$i$$の特徴ベクトル$$\boldsymbol{x}_{i}$$に対応する。このとき、次の問いに答えなさい。

### 07 アイテム集合
`Du`の各行のインデックス`i`は各アイテムアイテムID $$i$$に対応する。アイテム集合$$I$$（アイテムIDを要素としたベクトル）を`ndarray`のベクトルとして生成するコードを書きなさい。得られた`ndarray`を`I`とすること。

コード
```python
# アイテム集合
【    問07    】
print('I = {}'.format(I))
```

結果
```bash
I = [ 0  1  2  3  4  5  6  7  8  9 10 11 12]
```

★★
1. `numpy.arange()`を使う。
2. `ndarray.shape`を使う。

### 08 アイテムの特徴ベクトルの集合
`Du`からアイテムの特徴ベクトルの集合（各アイテムの特徴ベクトル$$\boldsymbol{x}_{i}$$を縦に結合した行列）を`ndarray`として生成するコードを書きなさい。得られた`ndarray`を`x`とすること。

コード
```python
# アイテムの特徴ベクトルの集合
【    問08    】
print('x = \n{}'.format(x))
```

結果
```bash
x = 
[[5. 3.]
 [6. 2.]
 [4. 1.]
 [8. 5.]
 [2. 4.]
 [3. 6.]
 [7. 6.]
 [4. 2.]
 [5. 1.]
 [8. 6.]
 [3. 4.]
 [4. 7.]
 [4. 4.]]
```

★★
1. 行列のスライスを使う。

### 09 アイテムiの特徴ベクトル
`x`からアイテム$$i$$の特徴ベクトル$$\boldsymbol{x}_{i}$$を取得するコードを書きなさい。

コード
```python
# アイテムiの特徴ベクトル
i = 0
【    問09    】
print('x{} = {}'.format(i, xi))
```

結果
```bash
x0 = [5. 3.]
```

★
1. インデキシングを使う。

## 評価値
評価履歴$$D_{u}$$の$$i$$行目の$$i$$行目3列目はユーザ$$u$$のアイテム$$i$$に対する評価値$$r_{u,i}$$に対応する。$$r_{u,i}=+1$$は「好き」を、$$r_{u,i}=-1$$は「嫌い」を表す。ただし、$$?$$はユーザ$$u$$が未評価、すなわち欠損値であることを示す。このとき、次の問いに答えなさい。

### 10 評価値集合
`Du`から評価値集合（各評価値$$r_{u,i}$$を要素としたベクトル）を`ndarray`のベクトルとして生成するコードを書きなさい。得られた`ndarray`を`ru`とすること。

コード
```python
# 評価値集合
【    問10    】
print('ru = {}'.format(ru))
```

結果
```bash
ru = [ 1.  1.  1. -1. -1. -1. -1. nan nan nan nan nan nan]
```

★★
1. スライシングを使う。

### 11 評価値集合の形状
`ru`の形状を取得し、表示するコードを書きなさい。

結果
```bash
ruの形状 = (13,)
```

★
1. `ndarray.shape`を使う。
2. `print()`を使う。

### 12 評価値集合の全要素数
`ru`の全要素数を取得し、表示するコードを書きなさい。ただし、欠損値も含む。

結果
```bash
ruの全要素数 = 13
```

★
1. `ndarray.size`を使う。
2. `print()`を使う。

★
1. `ndarray.shape`を使う。
2. `print()`を使う。

### 13 評価値集合の部分集合
`ru`の`i`番目から`j-1`番目までの評価値集合を取得し、表示するコードを書きなさい。

コード
```python
# i番目からj-1番目までの評価値集合
# 13
i = 2
j = 5
【    問13    】
```

結果
```bash
ru2からru4までの評価値 = [ 1. -1. -1.]
```

★
1. スライシングを使う。
2. `print()`を使う。

### 14 評価値集合の要素の逆順
`ru`の要素を逆順に取得し、表示するコードを書きなさい。

結果
```bash
ruの逆順 = [nan nan nan nan nan nan -1. -1. -1. -1.  1.  1.  1.]
```

★★
1. スライシングを使う。
2. `print()`を使う。

### 15 アイテムiに対する評価値
`ru`からアイテム$$i$$に対する評価値$$r_{u,i}$$を取得しなさい。得られた値を`rui`とすること。

コード
```python
# アイテムiに対する評価値
i = 0
【    問15    】
print('ru{} = {}'.format(i, rui))
```

結果
```bash
ru00 = 1.0
```

★
1. インデキシングを使う。

## アイテム集合
アイテム集合$$I$$のうちユーザ$$u$$が評価済みのアイテム集合を$$I_{u} \subseteq I$$と表す。このうち、ユーザ$$u$$が「好き」と評価したアイテム集合を$$I_{u}^{+} \subseteq I$$（$$r_{u,i}=+1$$を満たすアイテム集合）、ユーザ$$u$$が「嫌い」と評価したアイテム集合を$$I_{u}^{-} \subseteq I$$（$$r_{u,i}=-1$$を満たすアイテム集合）と表す。また、ユーザ$$u$$が未評価のアイテム集合は$$\overline{I}_{u} = I \setminus I_{u}$$と表される。ここで、$$I \setminus I_{u}$$は$$I$$から$$I_{u}$$を引いた差集合を表す。このとき、次の問いに答えなさい。

### 16 ユーザuが未評価であるか否かの判定
`ru`において、欠損値の要素には`True`を、それ以外の要素には`False`を入れたブール値配列を生成し、表示するコードを書きなさい。

結果
```bash
ユーザuが未評価 = [False False False False False False False  True  True  True  True  True True]
```

★
1. `numpy.isnan()`を使う。

### 17 ユーザが評価済みであるか否かの判定
`ru`において、欠損値の要素には`False`を、それ以外の要素には`True`を入れたブール値配列を生成し、表示するコードを書きなさい。

結果
```bash
ユーザuが評価済み = [ True  True  True  True  True  True  True False False False False False False]
```

★
1. `numpy.isnan()`を使う。
2. `~`演算子を使う。

### 18 ユーザuが評価済みのアイテム集合
`I`からユーザ$$u$$が評価済みのアイテム集合$$I_{u}$$を`ndarray`として生成するコードを書きなさい。得られた`ndarray`を`Iu`とすること。

コード
```python
# ユーザuが評価済みのアイテム集合
【    問18    】
print('Iu = {}'.format(Iu))
```

結果
```bash
Iu = [0 1 2 3 4 5 6]
```

★★
1. ブール値インデキシングを使う。

### 19 ユーザuが「好き」と評価したアイテム集合
`I`からユーザ$$u$$が「好き」と評価したアイテム集合$$I_{u}^{+}$$を`ndarray`として生成するコードを書きなさい。得られた`ndarray`を`Iup`とすること。

コード
```python
# ユーザuが「好き」と評価したアイテム集合
【    問19    】
print('Iu+ = {}'.format(Iup))
```

結果
```bash
Iu+ = [0 1 2]
```

★★
1. ブール値インデキシングを使う。

### 20 ユーザuが「嫌い」と評価したアイテム集合
`I`からユーザ$$u$$が「嫌い」と評価したアイテム集合$$I_{u}^{-}$$を`ndarray`として生成するコードを書きなさい。得られた`ndarray`を`Iun`とすること。

コード
```python
# ユーザuが「嫌い」と評価したアイテム集合
【    問20    】
print('Iu- = {}'.format(Iun))
```

結果
```bash
Iu- = [3 4 5 6]
```

★★
1. ブール値インデキシングを使う。

### 21 ユーザuが未評価のアイテム集合
`I`からユーザ$$u$$が未評価のアイテム集合$$\overline{I}_{u}$$を`ndarray`として生成するコードを書きなさい。得られた`ndarray`を`Iu_not`とすること。

コード
```python
# ユーザuが未評価のアイテム集合
【    問21    】
print('Iu_not = {}'.format(Iu_not))
```

結果
```bash
Iu_not = [ 7  8  9 10 11 12]
```

★★
1. `numpy.isnan()`を使う。
2. ブール値インデキシングを使う。

★★
1. `numpy.setdiff1d()`を使う。

## 訓練データと予測対象データ
評価履歴$$D_{u}$$からユーザ$$u$$の訓練データ$$D_{u}^{L}$$を作成すると、次のとおりとなる。

$$
D_{u}^{L} = \left[
 \begin{array}{rrr}
  5 & 3 & +1 \\
  6 & 2 & +1 \\
  4 & 1 & +1 \\
  8 & 5 & -1 \\
  2 & 4 & -1 \\
  3 & 6 & -1 \\
  7 & 6 & -1 \\
 \end{array}
\right]
$$

ここで、訓練データ$$D_{u}^{L}$$に含まれる事例数は$$\mid D_{u}^{L} \mid = 7$$となる。また、訓練データ$$D_{u}^{L}$$のうち「好き」と評価された事例集合（正事例集合）を$$D_{u}^{L+}$$、「嫌い」と評価された事例集合（負事例集合）を$$D_{u}^{L-}$$と表す。それぞれの事例数は$$\mid D_{u}^{L+} \mid = 3$$、$$\mid D_{u}^{L-} \mid = 4$$となる。同様に、ユーザ$$u$$向けの予測対象データ$$D_{u}^{U}$$は次のとおりとなる。

$$
D_{u}^{U} = \left[
 \begin{array}{rrr}
  4 & 2 &  ? \\
  5 & 1 &  ? \\
  8 & 6 &  ? \\
  3 & 4 &  ? \\
  4 & 7 &  ? \\
  4 & 4 &  ? \\
 \end{array}
\right]
$$

ここで、予測対象データ$$D_{u}^{U}$$に含まれる事例数は$$\mid D_{u}^{U} \mid = 6$$となる。このとき、次の問いに答えなさい。

### 22 訓練データ
`Du`から訓練データ$$D_{u}^{L}$$を`ndarray`として生成するコードを書きなさい。得られた`ndarray`を`DuL`とすること。

コード
```python
# 訓練データ
【    問22    】
print('DuL = {}'.format(DuL))
```

結果
```bash
DuL = [[ 5.  3.  1.]
 [ 6.  2.  1.]
 [ 4.  1.  1.]
 [ 8.  5. -1.]
 [ 2.  4. -1.]
 [ 3.  6. -1.]
 [ 7.  6. -1.]]
```

★
1. 整数配列インデキシングを使う。

### 23 訓練事例数
`DuL`から訓練事例数$$\mid D_{u}^{L} \mid$$を取得し、表示するコードを書きなさい。

結果
```bash
|DuL| = 7
```

★
1. `ndarray.shape`を使う。

### 24 正事例数
`DuL`から正事例数$$\mid D_{u}^{L+} \mid$$を取得し、表示するコードを書きなさい。

結果
```bash
|DuL+| = 3
```

★★
1. 整数配列インデキシングを使う。
2. ブール値インデキシングを使う。
3. `ndarray.shape`を使う。

### 24 負事例数
`DuL`から負事例数$$\mid D_{u}^{L-} \mid$$を取得し、表示するコードを書きなさい。

結果
```bash
|DuL-| = 4
```

★★
1. 整数配列インデキシングを使う。
2. ブール値インデキシングを使う。
3. `ndarray.shape`を使う。

### 26 予測対象データ
`Du`から予測対象データ$$D_{u}^{U}$$を`ndarray`として生成するコードを書きなさい。得られた`ndarray`を`DuU`とすること。

```python
# 予測対象データ
【    問27    】
print('DuU = {}'.format(DuU))
```

結果
```bash
DuU = [[ 4.  2. nan]
 [ 5.  1. nan]
 [ 8.  6. nan]
 [ 3.  4. nan]
 [ 4.  7. nan]
 [ 4.  4. nan]]
```

★
1. 整数配列インデキシングを使う。

### 27 予測対象事例数
`DuU`から訓練事例数$$\mid D_{u}^{U} \mid$$を取得し、表示するコードを書きなさい。

結果
```bash
|DuU| = 6
```

★
1. `ndarray.shape`を使う。
